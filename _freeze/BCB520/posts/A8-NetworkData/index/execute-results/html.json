{
  "hash": "b9abb4aa4e20827321630a2b56a076b9",
  "result": {
    "markdown": "---\ntitle: \"Practice with Network Data\"\nsubtitle: \"Nodes and Links and edges and vertices...\"\nformat:\n  html:\n    toc: false\n    echo: true\nauthor: \"Barrie Robison\"\ndate: \"2023-04-19\"\ncategories: [Portfolio, DataViz, Network, iGraph, Assignment]\nimage: \"wendigonetwork.png\"\ndescription: \"iGRAPH!\"\ncode-fold: true\ncode-tools: true\n---\n\n\n# OVERVIEW\n\nIn this assignment, we'll consider some of the tools and techniques for visualizing network data. Network data is characterized by two unique items that are not found in tabular or spatial data - Nodes and Links. In addition, there is a sub-type of network data that we will consider - Hierarchical or Tree data. Let's practice a few visualizations to get a feel for how these things work!\n\n# NETWORK BASICS!\n\nIn class we talked about the strong possibility that each of you will encounter network data in your research. These data could be describing lots of different things in biologicial syste,s, from gene or protein expression networks, to hierarchical representations of ontologies, to phylogenetic trees. In geology and geoinformatics, network data would be used to describe the co-occurence of mineral species, or even knowledge graphs and other information representations.\n\n## IGRAPH\n\nLet's start with [igraph](https://igraph.org), which is an open source toolset for network analysis. The great thing about igraph is that you can use these tools in R, Python, Mathematica, and C++. It is very flexible and very powerful.\n\n### igraph in R\n\nFirst up, we'll install R/igraph and load the library (note that I've commented out the package installation because I've already installed igraph on my machine):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"igraph\")\nlibrary(igraph)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'igraph'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:base':\n\n    union\n```\n:::\n:::\n\n\nNow I'm going to walk you through a modified version of the igraph tutorial, which you can find [here](https://r.igraph.org/articles/igraph.html)\n\n## Creating a graph\n\n`igraph` offers many ways to create a graph. The simplest one is the function `make_empty_graph`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_empty_graph()\n```\n:::\n\n\nThe most common way to create a graph is `make_graph`, which constructs a network based on specified edges. For example, to make a graph with 10 nodes (numbered `1` to `10`) and two edges connecting nodes `1-2` and `1-5`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(edges = c(1,2, 1,5), n=10, directed = FALSE)\n```\n:::\n\n\nWe can print the graph to get a summary of its nodes and edges:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH bc76029 U--- 10 2 -- \n+ edges from bc76029:\n[1] 1--2 1--5\n```\n:::\n:::\n\n\nThis means: **U**ndirected **N**amed graph with **10** vertices and **2** edges, with the exact edges listed out. If the graph has a `[name]` attribute, it is printed as well.\n\n::: callout-note\n`summary` does not list the edges, which is convenient for large graphs with millions of edges:\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH bc76029 U--- 10 2 -- \n```\n:::\n:::\n\n\nThe same function `make_graph` can create some notable graphs by just specifying their name. For example you can create the graph that represents the social network of Zachary's karate club, that shows the friendship between 34 members of a karate club at a US university in the 1970s:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph('Zachary')\n```\n:::\n\n\nTo visualize a graph you can use `plot`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n## Vertex and edge IDs\n\nVertices and edges have numerical vertex IDs in igraph. Vertex IDs are always consecutive and they start with 1. For a graph with n vertices the vertex IDs are always between 1 and n. If some operation changes the number of vertices in the graphs, e.g. a subgraph is created via `induced_subgraph`, then the vertices are renumbered to satisfy this criterion.\n\nThe same is true for the edges as well: edge IDs are always between 1 and m, the total number of edges in the graph.\n\nIn addition to IDs, vertices and edges can be assigned a name and other attributes. That makes it easier to track them whenever the graph is altered. \n\n## Adding/deleting vertices and edges\n\nLet's continue working with the Karate club graph. To add one or more vertices to an existing graph, use `add_vertices`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- add_vertices(g, 3)\n```\n:::\n\n\nSimilarly, to add edges you can use `add_edges`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- add_edges(g, edges = c(1,35, 1,36, 34,37))\n```\n:::\n\n\nEdges are added by specifying the source and target vertex IDs for each edge. This call added three edges, one connecting vertices `1` and `35`, one connecting vertices `1` and `36`, and one connecting vertices `34` and `37`.\n\nIn addition to the `add_vertices` and `add_edges` functions, the plus operator can be used to add vertices or edges to graph. The actual operation that is performed depends on the type of the right hand side argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- g + edges(c(1,35, 1,36, 34,37))\n```\n:::\n\n\nYou can add a single vertex/edge at a time using `add_vertex` and `add_edge`.\n\n\n\nLet us add some more vertices and edges to our graph. In `igraph` we can use the `magrittr` package, which provides a mechanism for chaining commands with the operator `%\\>%`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- g %>% add_edges(edges=c(1,34)) %>% add_vertices(3) %>%\n     add_edges(edges=c(38,39, 39,40, 40,38, 40,37))\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 3dacd24 U--- 40 86 -- Zachary\n+ attr: name (g/c)\n+ edges from 3dacd24:\n [1]  1-- 2  1-- 3  1-- 4  1-- 5  1-- 6  1-- 7  1-- 8  1-- 9  1--11  1--12\n[11]  1--13  1--14  1--18  1--20  1--22  1--32  2-- 3  2-- 4  2-- 8  2--14\n[21]  2--18  2--20  2--22  2--31  3-- 4  3-- 8  3--28  3--29  3--33  3--10\n[31]  3-- 9  3--14  4-- 8  4--13  4--14  5-- 7  5--11  6-- 7  6--11  6--17\n[41]  7--17  9--31  9--33  9--34 10--34 14--34 15--33 15--34 16--33 16--34\n[51] 19--33 19--34 20--34 21--33 21--34 23--33 23--34 24--26 24--28 24--33\n[61] 24--34 24--30 25--26 25--28 25--32 26--32 27--30 27--34 28--34 29--32\n[71] 29--34 30--33 30--34 31--33 31--34 32--33 32--34 33--34  1--35  1--36\n+ ... omitted several edges\n```\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWe now have an undirected graph with 40 vertices and 86 edges. Vertex and edge IDs are always *contiguous*, so if you delete a vertex all subsequent vertices will be renumbered. When a vertex is renumbered, edges are **not** renumbered, but their source and target vertices will be. Use `delete_vertices` and `delete_edges` to perform these operations. For instance, to delete the edge connecting vertices `1-34`, get its ID and then delete it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.edge.ids(g, c(1,34))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 82\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- delete_edges(g, 82)\n```\n:::\n\n\nAs an example, to create a broken ring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_ring(10) %>% delete_edges(\"10|1\")\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe example above shows that you can also refer to edges with strings containing the IDs of the source and target vertices, connected by a pipe symbol `|`. `\"10|1\"` in the above example means the edge that connects vertex 10 to vertex 1. Of course you can also use the edge IDs directly, or retrieve them with the `get.edge.ids` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_ring(5)\ng <- delete_edges(g, get.edge.ids(g, c(1,5, 4,5)))\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n## Constructing graphs\n\nIn addition to `make_empty_graph`, `make_graph`, and `make_graph_from_literal`, `igraph` includes many other function to construct a graph. Some are *deterministic*, i.e. they produce the same graph each single time, e.g. `make_tree`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph1 <- make_tree(127, 2, mode = \"undirected\")\nsummary(graph1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 2fc7e28 U--- 127 126 -- Tree\n+ attr: name (g/c), children (g/n), mode (g/c)\n```\n:::\n\n```{.r .cell-code}\nplot(graph1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nThis generates a regular tree graph with 127 vertices, each vertex having two children. No matter how many times you call `make_tree`, the generated graph will always be the same if you use the same parameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph2 <- make_tree(127, 2, mode = \"undirected\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical_graphs(graph1,graph2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOther functions generate graphs *stochastically*, i.e. they produce a different graph each time. For instance `sample_grg`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph1 <- sample_grg(100, 0.2)\nsummary(graph1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 01c9e84 U--- 100 549 -- Geometric random graph\n+ attr: name (g/c), radius (g/n), torus (g/l)\n```\n:::\n\n```{.r .cell-code}\nplot(graph1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nThis generates a geometric random graph: *n* points are chosen randomly and uniformly inside the unit square and pairs of points closer to each other than a predefined distance *d* are connected by an edge. If you generate GRGs with the same parameters, they will be different:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph2 <- sample_grg(100, 0.2)\nidentical_graphs(graph1, graph2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nplot(graph2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nA slightly looser way to check if the graphs are equivalent is via `isomorphic`. Two graphs are said to be isomorphic if they have the same number of components (vertices and edges) and maintain a one-to-one correspondence between vertices and edges, i.e., they are connected in the same way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisomorphic(graph1, graph2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nChecking for isomorphism can take a while for large graphs (in this case, the answer can quickly be given by checking the degree sequence of the two graphs). `identical_graph` is a stricter criterion than `isomorphic`: the two graphs must have the same list of vertices and edges, in exactly the same order, with same directedness, and the two graphs must also have identical graph, vertex and edge attributes.\n\n## Setting and retrieving attributes\n\nIn addition to IDs, vertex and edges can have *attributes* such as a name, coordinates for plotting, metadata, and weights. The graph itself can have such attributes too (e.g. a name, which will show in `summary`). In a sense, every graph, vertex and edge can be used as an R namespace to store and retrieve these attributes.\n\nTo demonstrate the use of attributes, let us create a simple social network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(~ Alice-Bob:Claire:Frank, Claire-Alice:Dennis:Frank:Esther,\n                George-Dennis:Frank, Dennis-Esther)\n```\n:::\n\n\nEach vertex represents a person, so we want to store ages, genders and types of connection between two people (`is_formal` refers to whether a connection between one person or another is formal or informal, i.e. colleagues or friends). The `\\$` operator is a shortcut to get and set graph attributes. It is shorter and just as readable as `graph_attr` and `set_graph_attr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$age <- c(25, 31, 18, 23, 47, 22, 50) \nV(g)$gender <- c(\"f\", \"m\", \"f\", \"m\", \"m\", \"f\", \"m\")\nE(g)$is_formal <- c(FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)\nsummary(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH b41a80c UN-- 7 9 -- \n+ attr: name (v/c), age (v/n), gender (v/c), is_formal (e/l)\n```\n:::\n:::\n\n\n`V` and `E` are the standard way to obtain a sequence of all vertices and edges, respectively. This assigns an attribute to *all* vertices/edges at once. Another way to generate our social network is with the use of `set_vertex_attr` and `set_edge_attr` and the operator `%\\>%`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(~ Alice-Bob:Claire:Frank, Claire-Alice:Dennis:Frank:Esther,\n                George-Dennis:Frank, Dennis-Esther) %>%\n  set_vertex_attr(\"age\", value = c(25, 31, 18, 23, 47, 22, 50)) %>%\n  set_vertex_attr(\"gender\", value = c(\"f\", \"m\", \"f\", \"m\", \"m\", \"f\", \"m\")) %>%\n  set_edge_attr(\"is_formal\", value = c(FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE))\nsummary(g)\n```\n:::\n\n\nTo assign or modify an attribute for a single vertex/edge:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE(g)$is_formal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nE(g)$is_formal[1] <- TRUE\nE(g)$is_formal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nAttribute values can be set to any R object, but note that storing the graph in some file formats might result in the loss of complex attribute values. Vertices, edges and the graph itself can all be used to set attributes, e.g. to add a date to the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng$date <- c(\"2022-02-11\")\ngraph_attr(g, \"date\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-02-11\"\n```\n:::\n:::\n\n\nTo retrieve attributes, you can also use `graph_attr`, `vertex_attr`, and `edge_attr`. To find the ID of a vertex you can use the function `match`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch(c(\"George\"), V(g)$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\nTo assign attributes to a subset of vertices or edges, you can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$name[1:3] <- c(\"Alejandra\", \"Bruno\", \"Carmina\")\nV(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 7/7 vertices, named, from b41a80c:\n[1] Alejandra Bruno     Carmina   Frank     Dennis    Esther    George   \n```\n:::\n:::\n\n\nTo delete attributes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- delete_vertex_attr(g, \"gender\")\nV(g)$gender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nIf you want to save a graph in R with all the attributes use the R's standard function `dput` function and retrieve it later with `dget`. You can also just save the R workspace and restore it later.\n\n## Structural properties of graphs\n\n`igraph` provides a large set of functions to calculate various structural properties of graphs. It is beyond the scope of this tutorial to document all of them, hence this section will only introduce a few of them for illustrative purposes. We will work on the small social network constructed in the previous section.\n\nPerhaps the simplest property one can think of is the *degree*. The degree of a vertex equals the number of edges adjacent to it. In case of directed networks, we can also define *in-degree* (the number of edges pointing towards the vertex) and *out-degree* (the number of edges originating from the vertex). `igraph` is able to calculate all of them using a simple syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlejandra     Bruno   Carmina     Frank    Dennis    Esther    George \n        3         1         4         3         3         2         2 \n```\n:::\n:::\n\n\nIf the graph was directed, we would have been able to calculate the in- and out-degrees separately using `degree(mode=\"in\")` and `degree(mode=\"out\")`. You can also pass a single vertex ID or a list of vertex IDs to `degree` if you want to calculate the degrees for only a subset of vertices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree(g, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeorge \n     2 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree(g, v=c(3,4,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCarmina   Frank  Dennis \n      4       3       3 \n```\n:::\n:::\n\n\nMost functions that accept vertex IDs also accept vertex *names* (i.e. the values of the `name` vertex attribute) as long as the names are unique:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree(g, v=c(\"Carmina\", \"Frank\", \"Dennis\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCarmina   Frank  Dennis \n      4       3       3 \n```\n:::\n:::\n\n\nIt also works for single vertices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree(g, \"Bruno\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBruno \n    1 \n```\n:::\n:::\n\n\nA similar syntax is used for most of the structural properties `igraph` can calculate. For vertex properties, the functions accept a vertex ID, a vertex name, or a list of vertex IDs or names (and if they are omitted, the default is the set of all vertices). For edge properties, the functions accept a single edge ID or a list of edge IDs.\n\n------------------------------------------------------------------------\n\n**NOTE:** For some measures, it does not make sense to calculate them only for a few vertices or edges instead of the whole graph, as it would take the same time anyway. In this case, the functions won't accept vertex or edge IDs, but you can still restrict the resulting list later using standard operations. One such example is eigenvector centrality (`evcent()`).\n\n------------------------------------------------------------------------\n\nBesides degree, igraph includes built-in routines to calculate many other centrality properties, including vertex and edge betweenness (`edge_betweenness`) or Google's PageRank (`page_rank`) just to name a few. Here we just illustrate edge betweenness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedge_betweenness(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 6 4 3 4 4 4 2 3\n```\n:::\n:::\n\n\nNow we can also figure out which connections have the highest betweenness centrality:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nebs <- edge_betweenness(g)\nas_edgelist(g)[ebs == max(ebs), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]        [,2]     \n[1,] \"Alejandra\" \"Bruno\"  \n[2,] \"Alejandra\" \"Carmina\"\n```\n:::\n:::\n\n\n## Querying vertices and edges based on attributes\n\n### Selecting vertices\n\nImagine that in a given social network, you want to find out who has the largest degree. You can do that with the tools presented so far and the `which.max` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich.max(degree(g))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCarmina \n      3 \n```\n:::\n:::\n\n\nAnother example would be to select only vertices that have only odd IDs but not even ones, using the `V` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- graph.full(n=10)\nonly_odd_vertices <- which(V(graph)%%2==1)\nlength(only_odd_vertices)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nOf course, it is possible to select vertices or edges by positional indices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq <- V(graph)[2, 3, 7]\nseq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 3/10 vertices, from 34c4bd9:\n[1] 2 3 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq <- seq[1, 3]    # filtering an existing vertex set\nseq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 2/10 vertices, from 34c4bd9:\n[1] 2 7\n```\n:::\n:::\n\n\nSelecting a vertex that does not exist results in an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq <- V(graph)[2, 3, 7, \"foo\", 3.5]\n## Error in simple_vs_index(x, ii, na_ok) : Unknown vertex selected\n```\n:::\n\n\nAttribute names can also be used as-is within the indexing brackets of `V()` and `E()`. This can be combined with R's ability to use boolean vectors for indexing to obtain very concise and readable expressions to retrieve a subset of the vertex or edge set of a graph. For instance, the following command gives you the names of the individuals younger than 30 years in our social network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)[age < 30]$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alejandra\" \"Carmina\"   \"Frank\"     \"Esther\"   \n```\n:::\n:::\n\n\nOf course, `<` is not the only boolean operator that can be used for this. Other possibilities include the following:\n\n| Operator | Meaning                                                         |\n|----------------------|--------------------------------------------------|\n| `==`     | The attribute/property value must be *equal to*                 |\n| `!=`     | The attribute/property value must *not be equal to*             |\n| `<`      | The attribute/property value must be *less than*                |\n| `<=`     | The attribute/property value must be *less than or equal to*    |\n| `>`      | The attribute/property value must be *greater than*             |\n| `>=`     | The attribute/property value must be *greater than or equal to* |\n| `%in%`   | The attribute/property value must be *included in*              |\n\nYou can also create a \"not in\" operator from `%in%` using the `Negate` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%notin%` <- Negate(`%in%`)\n```\n:::\n\n\nIf an attribute has the same name as an `igraph` function, you should be careful as the syntax can become a little confusing. For instance, if there is an attribute named `degree` that represents the grades of an exam for each person, that should not be confused with the `igraph` function that computes the degrees of vertices in a network sense:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$degree <- c(\"A\", \"B\", \"B+\", \"A+\", \"C\", \"A\", \"B\")\nV(g)$degree[degree(g) == 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\"  \"A+\" \"C\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$name[degree(g) == 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alejandra\" \"Frank\"     \"Dennis\"   \n```\n:::\n:::\n\n\n### Selecting edges\n\nEdges can be selected based on attributes just like vertices. As mentioned above, the standard way to get edges is `E`. Moreover, there are a few special structural properties for selecting edges.\n\nUsing `.from` allows you to filter the edge sequence based on the source vertices of the edges. E.g., to select all the edges originating from Carmina (who has vertex index 3):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE(g)[.from(3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 4/9 edges from b41a80c (vertex names):\n[1] Alejandra--Carmina Carmina  --Frank   Carmina  --Dennis  Carmina  --Esther \n```\n:::\n:::\n\n\nOf course it also works with vertex names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE(g)[.from(\"Carmina\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 4/9 edges from b41a80c (vertex names):\n[1] Alejandra--Carmina Carmina  --Frank   Carmina  --Dennis  Carmina  --Esther \n```\n:::\n:::\n\n\nUsing `.to` filters edge sequences based on the target vertices. This is different from `.from` if the graph is directed, while it gives the same answer for undirected graphs. Using `.inc` selects only those edges that are incident on a single vertex or at least one of the vertices, irrespectively of the edge directions.\n\nThe `%--%` operator can be used to select edges between specific groups of vertices, ignoring edge directions in directed graphs. For instance, the following expression selects all the edges between Carmina (vertex index 3), Dennis (vertex index 5) and Esther (vertex index 6):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE(g) [ 3:5 %--% 5:6 ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 3/9 edges from b41a80c (vertex names):\n[1] Carmina--Dennis Carmina--Esther Dennis --Esther\n```\n:::\n:::\n\n\nTo make the `%--%` operator work with names, you can build string vectors containing the names and then use these vectors as operands. For instance, to select all the edges that connect men to women, we can do the following after re-adding the gender attribute that we deleted earlier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$gender <- c(\"f\", \"m\", \"f\", \"m\", \"m\", \"f\", \"m\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmen <- V(g)[gender == \"m\"]$name\nmen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Bruno\"  \"Frank\"  \"Dennis\" \"George\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwomen <- V(g)[gender == \"f\"]$name\nwomen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alejandra\" \"Carmina\"   \"Esther\"   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nE(g)[men %--% women]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 5/9 edges from b41a80c (vertex names):\n[1] Alejandra--Bruno  Alejandra--Frank  Carmina  --Frank  Carmina  --Dennis\n[5] Dennis   --Esther\n```\n:::\n:::\n\n\n## Treating a graph as an adjacency matrix\n\nThe adjacency matrix is another way to represent a graph. In an adjacency matrix, rows and columns are labeled by graph vertices, and the elements of the matrix indicate the number of edges between vertices *i* and *j*. The adjacency matrix for the example graph is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.adjacency(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7 x 7 sparse Matrix of class \"dgCMatrix\"\n          Alejandra Bruno Carmina Frank Dennis Esther George\nAlejandra         .     1       1     1      .      .      .\nBruno             1     .       .     .      .      .      .\nCarmina           1     .       .     1      1      1      .\nFrank             1     .       1     .      .      .      1\nDennis            .     .       1     .      .      1      1\nEsther            .     .       1     .      1      .      .\nGeorge            .     .       .     1      1      .      .\n```\n:::\n:::\n\n\nFor example, Carmina (`1, 0, 0, 1, 1, 1, 0`) is directly connected to Alejandra (who has vertex index 1), Frank (index 4), Dennis (index 5) and Esther (index 6), but not to Bruno (index 2) or to George (index 7).\n\n## Layouts and plotting\n\nA graph is an abstract mathematical object without a specific representation in 2D, 3D or any other geometric space. This means that whenever we want to visualise a graph, we have to find a mapping from vertices to coordinates in two- or three-dimensional space first, preferably in a way that is useful and/or pleasing for the eye. A separate branch of graph theory, namely graph drawing, tries to solve this problem via several graph layout algorithms. igraph implements quite a few layout algorithms and is also able to draw them onto the screen or to any output format that R itself supports.\n\n### Layout algorithms\n\nThe layout functions in igraph always start with `layout`. The following table summarises them:\n\n| Method name        | Algorithm description                                                                                          |\n|-----------------|-------------------------------------------------------|\n| `layout_randomly`  | Places the vertices completely randomly                                                                        |\n| `layout_in_circle` | Deterministic layout that places the vertices on a circle                                                      |\n| `layout_on_sphere` | Deterministic layout that places the vertices evenly on the surface of a sphere                                |\n| `layout_with_drl`  | The Drl (Distributed Recursive Layout) algorithm for large graphs                                              |\n| `layout_with_fr`   | Fruchterman-Reingold force-directed algorithm                                                                  |\n| `layout_with_kk`   | Kamada-Kawai force-directed algorithm                                                                          |\n| `layout_with_lgl`  | The LGL (Large Graph Layout) algorithm for large graphs                                                        |\n| `layout_as_tree`   | Reingold-Tilford tree layout, useful for (almost) tree-like graphs                                             |\n| `layout_nicely`    | Layout algorithm that automatically picks one of the other algorithms based on certain properties of the graph |\n\nLayout algorithms can be called directly with a graph as its first argument. They will return a matrix with two columns and as many rows as the number of vertices in the graph; each row will correspond to the position of a single vertex, ordered by vertex IDs. Some algorithms have a 3D variant; in this case they return three columns instead of 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- layout_with_kk(g)\n```\n:::\n\n\nSome layout algorithms take additional arguments; e.g., when laying out a graph as a tree, it might make sense to specify which vertex is to be placed at the root of the layout:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- layout_as_tree(g, root = 2)\n```\n:::\n\n\n### Drawing a graph using a layout\n\nWe can plot our imaginary social network with the Kamada-Kawai layout algorithm as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- layout_with_kk(g)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(g, layout = layout, main = \"Social network with the Kamada-Kawai layout algorithm\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\nThis should open a new window showing a visual representation of the network. Remember that the exact placement of nodes may be different on your machine since the layout is not deterministic.\n\nThe `layout` argument also accepts functions; in this case, the function will be called with the graph as its first argument. This makes it possible to just pass the name of a layout function directly, without creating a layout variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(g, layout = layout_with_fr,\n     main = \"Social network with the Fruchterman-Reingold layout algorithm\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n\nTo improve the visuals, a trivial addition would be to color the vertices according to the gender. We should also try to place the labels slightly outside the vertices to improve readability:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(g)$color <- ifelse(V(g)$gender == \"m\", \"yellow\", \"red\")\nplot(g, layout = layout, vertex.label.dist = 3.5,\n     main = \"Social network - with genders as colors\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\nYou can also treat the `gender` attribute as a factor and provide the colors with an argument to `plot()`, which takes precedence over the `color` vertex attribute. Colors will be assigned automatically to levels of a factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(g, layout=layout, vertex.label.dist=3.5, vertex.color=as.factor(V(g)$gender))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\nAs seen above with the `vertex.color` argument, you can specify visual properties as arguments to `plot` instead of using vertex or edge attributes. The following plot shows the formal ties with thick lines while informal ones with thin lines:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(g, layout=layout, vertex.label.dist=3.5, vertex.size=20,\n     vertex.color=ifelse(V(g)$gender == \"m\", \"yellow\", \"red\"),\n     edge.width=ifelse(E(g)$is_formal, 5, 1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n\nThis latter approach is preferred if you want to keep the properties of the visual representation of your graph separate from the graph itself.\n\nIn summary, there are special vertex and edge properties that correspond to the visual representation of the graph. These attributes override the default settings of igraph (i.e color, weight, name, shape,layout,etc.). The following two tables summarise the most frequently used visual attributes for vertices and edges, respectively:\n\n### Vertex attributes controlling graph plots\n\n| Attribute name | Keyword argument      | Purpose                                                                                                                                                                                                                                        |\n|----------------------|----------------------|-----------------------------|\n| `color`        | `vertex.color`        | Color of the vertex                                                                                                                                                                                                                            |\n| `label`        | `vertex.label`        | Label of the vertex. They will be converted to character. Specify NA to omit vertex labels. The default vertex labels are the vertex ids.                                                                                                      |\n| `label.cex`    | `vertex.label.cex`    | Font size of the vertex label, interpreted as a multiplicative factor, similarly to R's `text` function                                                                                                                                        |\n| `label.color`  | `vertex.label.color`  | Color of the vertex label                                                                                                                                                                                                                      |\n| `label.degree` | `vertex.label.degree` | It defines the position of the vertex labels, relative to the center of the vertices. It is interpreted as an angle in radian, zero means 'to the right', and 'pi' means to the left, up is -pi/2 and down is pi/2. The default value is -pi/4 |\n| `label.dist`   | `vertex.label.dist`   | Distance of the vertex label from the vertex itself, relative to the vertex size                                                                                                                                                               |\n| `label.family` | `vertex.label.family` | Font family of the vertex, similarly to R's `text` function                                                                                                                                                                                    |\n| `label.font`   | `vertex.label.font`   | Font within the font family of the vertex, similarly to R's `text` function                                                                                                                                                                    |\n| `shape`        | `vertex.shape`        | The shape of the vertex, currently \"circle\", \"square\", \"csquare\", \"rectangle\", \"crectangle\", \"vrectangle\", \"pie\" (see vertex.shape.pie), 'sphere', and \"none\" are supported, and only by the plot.igraph command.                              |\n| `size`         | `vertex.size`         | The size of the vertex, a numeric scalar or vector, in the latter case each vertex sizes may differ                                                                                                                                            |\n\n### Edge attributes controlling graph plots\n\n| Attribute name | Keyword argument    | Purpose                                                                                                                                                                                                                                     |\n|-------------------------|-----------------------------|-------------------|\n| `color`        | `edge.color`        | Color of the edge                                                                                                                                                                                                                           |\n| `curved`       | `edge.curved`       | A numeric value specifies the curvature of the edge; zero curvature means straight edges, negative values means the edge bends clockwise, positive values the opposite. TRUE means curvature 0.5, FALSE means curvature zero                |\n| `arrow.size`   | `edge.arrow.size`   | Currently this is a constant, so it is the same for every edge. If a vector is submitted then only the first element is used, ie. if this is taken from an edge attribute then only the attribute of the first edge is used for all arrows. |\n| `arrow.width`  | `edge.arrow.width`  | The width of the arrows. Currently this is a constant, so it is the same for every edge                                                                                                                                                     |\n| `width`        | `edge.width`        | Width of the edge in pixels                                                                                                                                                                                                                 |\n| `label`        | `edge.label`        | If specified, it adds a label to the edge.                                                                                                                                                                                                  |\n| `label.cex`    | `edge.label.cex`    | Font size of the edge label, interpreted as a multiplicative factor, similarly to R's `text` function                                                                                                                                       |\n| `label.color`  | `edge.label.color`  | Color of the edge label                                                                                                                                                                                                                     |\n| `label.family` | `edge.label.family` | Font family of the edge, similarly to R's `text` function                                                                                                                                                                                   |\n| `label.font`   | `edge.label.font`   | Font within the font family of the edge, similarly to R's `text` function                                                                                                                                                                   |\n\n### Generic arguments of `plot()`\n\nThese settings can be specified as arguments to the `plot` function to control the overall appearance of the plot.\n\n| Keyword argument | Purpose                                                                                                                                                                                                                                                           |\n|--------------------------------|----------------------------------------|\n| `layout`         | The layout to be used. It can be an instance of `Layout`, a list of tuples containing X-Y coordinates, or the name of a layout algorithm. The default is `auto`, which selects a layout algorithm automatically based on the size and connectedness of the graph. |\n| `margin`         | The amount of empty space below, over, at the left and right of the plot, it is a numeric vector of length four.                                                                                                                                                  |\n# A NON BORING EXAMPLE!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n\npeople<-read_xlsx(\"Networks.xlsx\", sheet = \"People\")\nrelations<-read_xlsx(\"Networks.xlsx\", sheet =\"Relations\")\n\ng <- graph_from_data_frame(relations, directed=FALSE, vertices=people)\n\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\nHave a look at the structure of the two dataframes (`people` and `relations`).  `igraph` is creating a graph object using the `relations` data frame as an edge list.  The rest of the elements are attributes of the nodes or the edges that we can use for visualization.\n\nWhile these examples are illustrative, they are also a bit contrived.  It is rare that you would manually make a network.  It is far more common that you will use existing data to visualize a network.  A big challenge is often converting your data into a format that `igraph` can work with, such as an edge list or adjacency matrix.\n\nFor example, what if we wanted to use the BCB520 variable in the `people` dataframe to create additional edges?\n\nThere are lots of ways to do this.  Here is one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:igraph':\n\n    as_data_frame, groups, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nBCB<-people%>%\n  filter(BCB520 == \"TRUE\")%>%\n  select(name, BCB520)\n\nedgelist<- combn(BCB$name, 2)\nedgelist_df <- as.data.frame(t(edgelist))\ncolnames(edgelist_df) <- c(\"from\", \"to\")\nedgelist_df$BCB520<-\"TRUE\"\nedgelist_df$Advisor<-\"FALSE\"\n\nrelations$BCB520 <- \"FALSE\"\n\nrelations3<-rbind(relations, edgelist_df)\n\ng <- graph_from_data_frame(relations3, directed=FALSE, vertices=people)\n\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-63-1.png){width=672}\n:::\n:::\n\n\n## ASSIGNMENT\n\nImprove the network above by:\n\n1. Coloring the edges according to Advisor / BCB520 attribute.\n2. Coloring the nodes according to Department.\n3. Adujsting the labels to improve readability.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}