{
  "hash": "43d48ae82b9c50ee9f721e9b8bc113f4",
  "result": {
    "markdown": "---\ntitle: \"LECTURE 6 - Tabular Data\"\nformat:\n  revealjs: \n    slide-number: true\n    chalkboard: \n      buttons: false\n    preview-links: auto\n    css: styles.css\n    footer: <a href=\"https://canvas.uidaho.edu/courses/17806\" target=\"_blank\">CANVAS</a>...<a href=\"https://professorpolymorphic.github.io/RobisonWebSite/BCB520/BCB520.html\" target=\"_blank\">HOME</a>\n    theme: [default, custom.scss]\nauthor: \"Barrie Robison\"\ndate: \"2023-02-28\"\ncategories: [Lecture, DataViz, Data, Tables]\nimage: \"Cthulhutabular.png\"\ncode-fold: true\n---\n\n\n## THE THREE MAJOR DATA TYPES\n\n::: r-stack\n![](Tables.png){.fragment .absolute bottom=\"100\" left=\"0\" height=\"400\"}\n\n![](Networks.png){.fragment .absolute bottom=\"100\" left=\"280\" height=\"400\"}\n\n![](Spatial.png){.fragment .absolute bottom=\"75\" left=\"520\" height=\"390\"}\n:::\n\n## WHAT?\n\nComputer-based visualization systems provide visual representations of [datasets]{.red} designed to help people carry out tasks more effectively.\n\n![](whatexpanded.png){.absolute bottom=\"0\" right=\"0\" width=\"450\"}\n\n![](what.png){.absolute bottom=\"0\" height=\"400\"}\n\n## SEMANTICS FOR DATA {.smaller}\n\n::: {layout-ncol=\"2\"}\n### Semantics\n\n-   [item:]{.red} individual entity, discrete\n    -   eg patient, car, stock, city\n    -   \"independent variable\"\n-   [attribute:]{.red} property that is measured, observed, logged...\n    -   eg height, blood pressure for patient\n    -   eg horsepower, make for car\n    -   \"dependent variable\"\n\n### Data Table\n\n![](datatable2.png)\n:::\n\n[ITEM:]{.red} Person\n\n[ATTRIBUTES:]{.red} Name, Age, Shirt Size, Favorite Fruit\n\n## DATASET TYPES: TABLES\n\n### Flat Table\n\n::: columns\n::: {.r-fit-text .column width=\"40%\"}\n-   One [ITEM]{.red} per row\n\n    -   often called an **observation**\n\n-   Each column is an [ATTRIBUTE]{.red}\n\n    -   often called a **variable**\n\n-   A cell holds the [VALUE]{.red} for an item/attribute pair\n\n-   A unique [KEY]{.red} can be used (implicitly or explicitly) to identify each item even if they share all measured attributes\n:::\n\n::: {.column width=\"60%\"}\n![](flattable.png)\n:::\n:::\n\n## FLAT TABLE EXAMPLE\n\n::: {#fig-tables layout-ncol=\"2\"}\n![A dumb spreadsheet](spreadsheet.png)\n\n![A cool spreadsheet](Cthulhuflat.png){width=\"380\"}\n\nFlat Tables\n:::\n\n## MULTIDIMENSIONAL TABLES\n\nIndexing based on multiple [keys]{.red} (eg genes, patients)\n\n::: {layout-ncol=\"2\"}\n![](multidimtable1.png)\n\n![](multidimtable2.png)\n:::\n\n## KEYS AND VALUES {.smaller}\n\n::: columns\n::: {.column width=\"60%\"}\n[KEY:]{.red} an independent attribute used as unique index to look up items.\n\n-   Simple tables: 1 key\n\n-   Multidimensional tables: multiple keys\n\n[Value:]{.red} a dependent attribute, value of cell\n\nWe will classify visualization idioms by the number of keys used.\n\n0, 1, 2, ...\n:::\n\n::: {.column width=\"40%\"}\n![](numkeys.png)\n:::\n:::\n\n## IDIOM: Scatterplot {.smaller}\n\n**0 KEYS:** Only values are available or salient to the task.\n\n::: columns\n::: {.column width=\"60%\"}\n**Express values** (magnitudes) of quantitative attributes.\n\n**Data:** 2 quantitative attributes\n\n**Mark:** points\n\n**Channels:** horizontal and verical position\n\n**Tasks:** find trends, outliers, distribution, correlation, clusters\n\n**Scalability:** hundreds of items\n:::\n\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![Height and Weight of drafted NHL players.](index_files/figure-revealjs/unnamed-chunk-1-1.png){width=384}\n:::\n:::\n\n:::\n:::\n\n## IDIOM: Scatterplot {.smaller}\n\n**0 KEYS:** Only values are available or salient to the task.\n\n::: columns\n::: {.column width=\"60%\"}\n**Express values** (magnitudes) of quantitative attributes.\n\n**Data:** 2 quantitative attributes\n\n**Mark:** points\n\n**Channels:** horizontal and verical position\n\n**Tasks:** find trends, [outliers]{.red}, distribution, correlation, clusters\n\n**Scalability:** hundreds of items\n:::\n\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![Height and Weight of drafted NHL players.](index_files/figure-revealjs/unnamed-chunk-2-1.png){width=384}\n:::\n:::\n\n:::\n:::\n\n## SCATTERPLOTS: More channels {.smaller}\n\n**Additional channels are viable with scatterplots since we are using point marks.**\n\n::: columns\n::: {.column width=\"40%\"}\n**Examples:**\n\n**Color:** But pay attention to Discriminability!\n\n**Size:** But pay attention to using a quantitative attribute used to control 2D area. Directly encoding radius would mislead. Take the square root since area grows quadratically.\n\n**Shape:**\n:::\n\n::: {.column width=\"60%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![Height and Weight of drafted NHL goaltenders.](index_files/figure-revealjs/unnamed-chunk-3-1.png){width=480}\n:::\n:::\n\n:::\n:::\n\n## SCATTERPLOT TASKS\n\nCorrelation\n\n![](correl.png)\n\nClusters/groups, and clusters vs classes\n\n![](clusters.png)\n\n## KEYS: Categorical Regions {.smaller}\n\n::: columns\n::: {.column width=\"40%\"}\n-   Regions: contiguous bounded areas distinct from each other\n    -   [NO OVERPLOTTING:]{.red} separate into spatial regions: one mark per region (for now)\n-   use categorical or ordered attribute to separate into regions\n    -   no conflict with expressiveness principle for categorical attributes\n-   use ordered attribute to order and align regions\n:::\n\n::: {.column width=\"60%\"}\n![](somekeys.png)\n\n![](sepordalign.png)\n:::\n:::\n\n## Separated and aligned and ordered\n\nBest case!\n\n![](orderedbar.png)\n\n## Separated/aligned - not ordered\n\nLimitation: hard to know rank. what's 4th? what's 7th?\n\n![](unorderedbar.png)\n\n## Separated but not aligned or ordered\n\nLimitation: hard to make comparisons with size (vs aligned position)\n\n![](circles.png)\n\n## IDIOM: Bar Chart {.smaller}\n\n**One key, One value**\n\n::: columns\n::: {.column width=\"60%\"}\n**Data:** 1 categorical attribute, 1 quantitative attribute\n\n**Mark:** Lines\n\n**Channels:** Length to express quantitative value\n\n**Spatial regions:** one per mark - separated horizontally, aligned vertically. Ordered by quantitative attribute: by label (alphabetical), by length attribute (data-driven)\n\n**Tasks:** compare, lookup values\n\n**Scalability:** dozens to hundreds of levels for key attribute (bars), hundreds for values.\n:::\n\n::: {.column width=\"40%\"}\n![](animalbar.png)\n:::\n:::\n\n## IDIOM: Stacked Bar Chart {.smaller}\n\n**Two keys, One value**\n\n::: columns\n::: {.column width=\"60%\"}\n**Data:** 2 categorical attribute, 1 quantitative attribute\n\n**Mark:** vertical stack of line marks\n\n**Glyph:** composite object, internal structure from multiple marks\n\n**Channels:** length and color hue\n\n**Spatial regions:** one per glyph\n\n**Aligned:** full glyph, lowest bar component\n\n**Unaligned:** other bar components\n\n**Task:** part-to-whole relationship\n\n**Scalability:** asymmetric for stacked key attrib, 10-12 levels segments for main key attrib, dozens to hundreds of levels bars\n:::\n\n::: {.column width=\"40%\"}\n\n![](stackedbar.png)\n\n:::\n:::\n\n## IDIOM: Streamgraph {.smaller}\n\nGeneralized stacked graph emphasizing horizontal continuity vs vertical items [(example)](https://observablehq.com/@d3/streamgraph-transitions)\n\n::: columns\n::: {.column width=\"40%\"}\n**Data:** 1 categ key attrib (movies) 1 ordered key attrib (time) 1 quant value attrib (counts) derived data geometry: layers, where height encodes counts 1 quant attrib (layer ordering)\n\n**Mark:** vertical stack of line marks\n\n**Channels:** length and color hue\n\n\n**Task:** part-to-whole relationship\n\n**Scalability:** hundreds of time keys dozens to hundreds of movies keys more than stacked bars: most layers don't extend across whole chart\n\n:::\n\n::: {.column width=\"60%\"}\n![](stream.png)\n\n![](stream2.png)\n:::\n:::\n\n## IDIOM: Dot/Line Chart {.smaller}\n\n**One key, One value**\n\n::: columns\n::: {.column width=\"60%\"}\n\n**Data:**2 quant attribs\n\n**Mark:** points AND line connection marks between them \n\n**Channels:** aligned lengths to express quant value separated and ordered by key attrib into horizontal regions\n\n**Task:** find trend connection marks emphasize ordering of items along key axis by explicitly showing relationship between one item and the next \n\n**Scalability:** hhundreds of key levels, hundreds of value levels\n\n:::\n\n::: {.column width=\"40%\"}\n\n![](dotline.png){height=\"500\"}\n:::\n::::\n\n## BAR vs LINE CHARTS {.smaller}\n\nChoice depends on the type of key attributes.\n\nBar charts if categorical, Line charts if ordered. Do not use line charts for categorical key attributes as it violates the **expressiveness principle**. The implication of trend is so strong that it overrides semantics. \"The more male a person is, the taller he/she is\"\n\n![](barsandlines.png)\n\n## CHART AXES {.smaller}\n\n::::{.columns}\n:::{.column width=\"30%\"}\n\n**Best practice to label axes**, with few exceptions. Individual small multiple views could share axis label.\n\n**Include 0** at bottom left or the slope misleads.  There are some exceptions (arbitrary 0, small change matters).\n\nTruncating the Y-Axis: Threat or Menace? Correll, Bertini, & Franconeri, CHI 2020.\n\n:::\n\n:::{.column width=\"50%\"}\n\n![](axes1.png)\n\n:::\n\n:::{.column width=\"20%\"}\n\n![](axes2.png)\n\n:::\n::::\n\n## IDIOM: Indexed Line Charts {.smaller}\n\n::::{.columns}\n:::{.column width=\"40%\"}\n\n**Data:** 2 quant attribs 1 key + 1 value \n\n**Derived data:** new quant value attrib index plot instead of original value \n\n**Task:** show change over time \n\n**Principle:** normalized, not absolute \n\n**Scalability:** same as standard line chart\n\n:::\n\n:::{.column width=\"60%\"}\n\n![](indexedline.png)\n\n[Cool Example](https://observablehq.com/@vega/vega-lite-interactive-index-chart)\n\n:::\n::::\n\n## IDIOM: Gantt Charts {.smaller}\n\none key, two (related) values\n\n::::{.columns}\n:::{.column width=\"40%\"}\n\n**Data:** 1 categ attrib, 2 quant attribs \n\n**Mark:** line length: duration\n\n**Channels:** horiz position: start time (+end from duration)\n\n**Task:** mphasize temporal overlaps & start/end dependencies between items\n\n**Scalability:** dozens of key levels bars hundreds of value levels durations\n:::\n\n:::{.column width=\"60%\"}\n\n![](gantt.png)\n:::\n::::\n\n\n## IDIOM: Slopegraphs {.smaller}\n\ntwo values \n\n::::{.columns}\n:::{.column width=\"40%\"}\n\n**Data:** 2 quant value attribs (1 derived attrib: change magnitude)  \n\n**Mark:** point + line line connecting mark between pts\n\n**Channels:** 2 vertical pos: express attrib value (linewidth/size, color) \n\n**Task:** emphasize changes in rank/value\n\n**Scalability:** hundreds of value levels dozens of item\n:::\n\n:::{.column width=\"60%\"}\n\n![](slopegraph.png)\n:::\n::::\n\n## 2 KEYS\n\n## IDIOM: Heatmap {.smaller}\n\ntwo keys, one value \n\n::::{.columns}\n:::{.column width=\"40%\"}\n\n**Data:** 2 categ attribs (gene, experimental condition) 1 quant attrib (expression levels) \n\n**Mark:** point separate and align in 2D matrix indexed by 2 categorical attributes \n\n**Channels:** color by quant attrib (ordered diverging colormap) \n\n**Task:** find clusters, outliers\n\n**Scalability:** 1M items, 100s of categ levels, \\~10 quant attrib levels\n:::\n\n:::{.column width=\"60%\"}\n\n![](heatmapbad.png)\n:::\n::::\n\n\n\n\n## HEATMAP REORDERING\n\n![](heatmaporder.png)\n\n## CLUSTERED HEATMAP {.smaller}\n\n[Use derived data:]{.red} compute 2 cluster hierarchies and represent as a dendrogram. Parent-child relationships represented in tree with connection line marks, leaves aligned so interior branch heights are easy to compare. Heatmap marks are (re-)ordered by cluster hierarchy traversal. **Task:** assess quality of clusters found by automatic methods\n\n![](heatmapcluster.png)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}