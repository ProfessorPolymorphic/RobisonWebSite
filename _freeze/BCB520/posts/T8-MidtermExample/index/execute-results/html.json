{
  "hash": "4d1aac117aea4e27c1f87b45184f3cf8",
  "result": {
    "markdown": "---\ntitle: \"BCB 520 - Midterm Portfolio Post\"\nsubtitle: \"State Level Infection Dynamics of the Zombie Apocalypse\"\nformat:\n  html:\n    toc: false\n    echo: false\nauthor: \"Barrie Robison\"\ndate: \"2023-04-04\"\ncategories: [Portfolio, DataViz, Infectious Disease, Observable, Animation]\nimage: \"Zomsimmesh.png\"\ndescription: \"Animating the dynamics of zombie spatial disease ecology.\"\ncode-fold: true\ncode-tools: true\n---\n\n\n## OVERVIEW\n\nThis assignment provides you the opportunity to synthesize all of the concepts we've covered in the course to date. The basic framework is that you will create a COMPLETE data visualization BLOG post that is suitable as a showcase component of your Data Science Portfolio. The point is to [SHOW]{.red} people your skills.\n\n## STRUCTURE\n\nThe basic formatting guidelines for this assignment are:\n\n1.  Include `code fold` or `code tools` options (or both) that allow users to view and copy your code while maintaining overall readability of your post.\n2.  Suppress all output and warnings that might distract from your visualizations and writing.\n3.  Properly title your assignment. The main title should be **\"BCB 520 - Midterm Portfolio Post\"**, and the subtitle should be a descriptive title related to your question or topic.\n4.  Include author, date, categories, and a description in your YAML header.\n5.  Write clear, complete sentences for a target audience with some scientific background but little training in your specific discipline.\n6.  Include references if appropriate and use hyperlinks to external sources of data, inspiration, or examples.\n7.  Use the header hierarchy and create a sensible document outline with white space. Format for readability! Use **bold** and *italic* fonts to emphasize things! Use [color]{.red} by customizing your `.css` file!\n\n**In addition to the above formatting guidelines, your portfolio post must contain the following sections:**\n\n## PREAMBLE\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nLoading required package: timechange\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n:::\n\nZOMBIES.\n\nZombies have undergone a significant evolution as a horror trope in fiction. The concept of zombies dates back to Haitian folklore and Voodoo, where they were depicted as reanimated corpses that were controlled by a sorcerer or bokor. However, in modern fiction, zombies are typically portrayed as mindless, flesh-eating creatures that are reanimated by a virus or some other mysterious force.\n\nThe evolution of zombies as a horror trope can be divided into several distinct eras:\n\n1. Classic Zombies: The classic zombie was the original Haitian zombie, which was introduced to Western audiences in the early 20th century through literature and film. These zombies were depicted as slow-moving, mind-controlled creatures that were raised from the dead by Voodoo magic.\n\n2. Romero Zombies: George A. Romero's 1968 film \"Night of the Living Dead\" redefined the zombie genre by introducing the idea that zombies were reanimated by a mysterious virus that spread through bites and scratches. Romero's zombies were slow-moving, flesh-eating creatures that could only be killed by destroying the brain.\n\n3. Fast Zombies: In the early 2000s, a new type of zombie emerged in fiction that could run and move at incredible speeds. These fast zombies were popularized by films like \"28 Days Later\" and \"World War Z.\" Fast zombies are often depicted as being more aggressive and intelligent than their slow-moving counterparts.\n\n4. Post-Apocalyptic Zombies: In recent years, zombies have been featured in a number of post-apocalyptic settings, where they are often portrayed as the cause of a global pandemic that has devastated humanity. These stories often focus on the struggle of survivors to rebuild civilization in a world overrun by the undead.\n\nOverall, the evolution of zombies as a horror trope has been marked by a shift from mind-controlled creatures to virus-infected monsters. \n\nBut would an outbreak of a \"zombie virus\" actually consume the world and bring forth an apocalyptic new age of shambling horror?\n\nLet's use disease modeling to find out!\n\n## Data\n\nI'm going to use our new interactive simulation, [OUTBREAK SIMULATOR](https://professorpolymorphic.github.io/PolymorphicWeb/Games/OutbreakSimulator/), to understand the dynamics of a zombie virus outbreak.\n\n### Parameters\n\nIn order to model this outbreak, we'll need to set some of the classic parameters of an SIR compartment model. Outbreak Simulator uses a compartment model of disease (Weissman et al., 2020) in which the population is divided into categories (Figure 1): Susceptible (S), Exposed (E), Infected (I), Vaccinated (V), Recovered (R), or Deceased (D). The model estimates the rates of exchange between categories over a given time interval (t) using differential equations. When the model parameters are known and key assumptions are met, the differential equations can estimate the epidemic curve of an outbreak. The two most critical assumptions are that the population is homogeneous and well mixed and is fixed in size. \n\n![](OSFig1.jpg)\n\nI've provided my own estimates of these parameters for various infectious zombie franchises in the table below.\n\n\n::: {.cell}\n::: {.cell-output-display}\n|Parameter             |Definition                                               |Resident Evil |World War Z |Walking Dead          |\n|:---------------------|:--------------------------------------------------------|:-------------|:-----------|:---------------------|\n|BETA                  |Rate of transmission                                     |19.8          |198         |20                    |\n|contact rate          |Number of infectious contacts (bites) per hour           |20            |200         |20                    |\n|infection probability |Chance that a bite causes infection                      |0.99          |0.99        |1                     |\n|ALPHA                 |Transformation rate                                      |0.5           |1000        |2.0833333333333332E-2 |\n|latency               |average number of hours until transformation to Infected |2             |1E-3        |48                    |\n|GAMMA                 |Recovery rate                                            |0             |0           |0                     |\n|DELTA                 |Mortality rate                                           |1             |1           |1                     |\n|infection duration    |average lifespan of a zombie in hours                    |250           |250         |250                   |\n|SIGMA                 |Vaccination rate                                         |0             |0           |0                     |\n|R0 Initial            |Initial basic reproduction rate of the virus             |4950          |49500       |5000                  |\n|Speed                 |How fast can the zombies move?                           |Slow          |Fast        |Slow                  |\n:::\n:::\n\n\n### Data Dictionary\n\nOutbreak Simulator runs the compartment model on a spatially explicit grid of the continental US.  It writes the number of individuals in each compartment (SIERD) at each time step (an hour) for each of the 48 states and the total population. \n\nThis is a video of the simulation:\n\n![](zombievid_1.mp4)\n\n\n::: {.cell}\n\n:::\n\n\nI'll manipulate the raw data a bit to get to the visualizations I need.  First, I want a tidy data set with only the total US population.\n\n\n::: {.cell}\n\n:::\n\nThis allows me to produce the classic Epidemilogical Curve:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n## STATE LEVEL DYNAMICS\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n### Visualizations\n\nCreate your visualizations and include text that explains any steps or design choices. Be sure to include clearly labeled axes and a concise but complete figure caption for each visualization. Make deliberate choices for color palettes, point marks, line types, etc. Demonstrate that you understand the concepts we have covered!\n\n\nhttps://observablehq.com/d/c28318bc4edfb4c1\n\n\n```{ojs}\n\ndata = d3.csvParse(await FileAttachment(\"Zomstates.csv\").text(), d3.autoType)\n\nviewof replay = html`<button>Replay`\n\n```\n\n```{ojs}\n\n\n\nchart = {\n  \n  replay;\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height]);\n\n  const updateBars = bars(svg);\n  const updateAxis = axis(svg);\n  const updateLabels = labels(svg);\n  const updateTicker = ticker(svg);\n\n  yield svg.node();\n\n  for (const keyframe of keyframes) {\n    const transition = svg.transition()\n        .duration(duration)\n        .ease(d3.easeLinear);\n\n    // Extract the top bar’s value.\n    x.domain([0, keyframe[1][0].value]);\n\n    updateAxis(keyframe, transition);\n    updateBars(keyframe, transition);\n    updateLabels(keyframe, transition);\n    updateTicker(keyframe, transition);\n\n    invalidation.then(() => svg.interrupt());\n    await transition.end();\n  }\n}\n\n\nduration = 25\nn = 50\nk = 10\nnames = new Set(data.map(d => d.name))\n\n\ndatevalues = Array.from(d3.rollup(data, ([d]) => d.value, d => +d.date, d => d.name))\n  .map(([date, data]) => [new Date(date), data])\n  .sort(([a], [b]) => d3.ascending(a, b))\n  \n  \nfunction rank(value) {\n  const data = Array.from(names, name => ({name, value: value(name)}));\n  data.sort((a, b) => d3.descending(a.value, b.value));\n  for (let i = 0; i < data.length; ++i) data[i].rank = Math.min(n, i);\n  return data;\n}\n\nkeyframes = {\n  const keyframes = [];\n  let ka, a, kb, b;\n  for ([[ka, a], [kb, b]] of d3.pairs(datevalues)) {\n    for (let i = 0; i < k; ++i) {\n      const t = i / k;\n      keyframes.push([\n        new Date(ka * (1 - t) + kb * t),\n        rank(name => (a.get(name) || 0) * (1 - t) + (b.get(name) || 0) * t)\n      ]);\n    }\n  }\n  keyframes.push([new Date(kb), rank(name => b.get(name) || 0)]);\n  return keyframes;\n}\n\nnameframes = d3.groups(keyframes.flatMap(([, data]) => data), d => d.name)\n\nprev = new Map(nameframes.flatMap(([, data]) => d3.pairs(data, (a, b) => [b, a])))\n\nnext = new Map(nameframes.flatMap(([, data]) => d3.pairs(data)))\n\nfunction bars(svg) {\n  let bar = svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.6)\n    .selectAll(\"rect\");\n\n  return ([date, data], transition) => bar = bar\n    .data(data.slice(0, n), d => d.name)\n    .join(\n      enter => enter.append(\"rect\")\n        .attr(\"fill\", color)\n        .attr(\"height\", y.bandwidth())\n        .attr(\"x\", x(0))\n        .attr(\"y\", d => y((prev.get(d) || d).rank))\n        .attr(\"width\", d => x((prev.get(d) || d).value) - x(0)),\n      update => update,\n      exit => exit.transition(transition).remove()\n        .attr(\"y\", d => y((next.get(d) || d).rank))\n        .attr(\"width\", d => x((next.get(d) || d).value) - x(0))\n    )\n    .call(bar => bar.transition(transition)\n      .attr(\"y\", d => y(d.rank))\n      .attr(\"width\", d => x(d.value) - x(0)));\n}\n\n\nfunction labels(svg) {\n  let label = svg.append(\"g\")\n      .style(\"font\", \"bold 12px var(--sans-serif)\")\n      .style(\"font-variant-numeric\", \"tabular-nums\")\n      .attr(\"text-anchor\", \"end\")\n    .selectAll(\"text\");\n\n  return ([date, data], transition) => label = label\n    .data(data.slice(0, n), d => d.name)\n    .join(\n      enter => enter.append(\"text\")\n        .attr(\"transform\", d => `translate(${x((prev.get(d) || d).value)},${y((prev.get(d) || d).rank)})`)\n        .attr(\"y\", y.bandwidth() / 2)\n        .attr(\"x\", -6)\n        .attr(\"dy\", \"-0.25em\")\n        .text(d => d.name)\n        .call(text => text.append(\"tspan\")\n          .attr(\"fill-opacity\", 0.7)\n          .attr(\"font-weight\", \"normal\")\n          .attr(\"x\", -6)\n          .attr(\"dy\", \"1.15em\")),\n      update => update,\n      exit => exit.transition(transition).remove()\n        .attr(\"transform\", d => `translate(${x((next.get(d) || d).value)},${y((next.get(d) || d).rank)})`)\n        .call(g => g.select(\"tspan\").tween(\"text\", d => textTween(d.value, (next.get(d) || d).value)))\n    )\n    .call(bar => bar.transition(transition)\n      .attr(\"transform\", d => `translate(${x(d.value)},${y(d.rank)})`)\n      .call(g => g.select(\"tspan\").tween(\"text\", d => textTween((prev.get(d) || d).value, d.value))))\n}\n\nfunction textTween(a, b) {\n  const i = d3.interpolateNumber(a, b);\n  return function(t) {\n    this.textContent = formatNumber(i(t));\n  };\n}\n\nformatNumber = d3.format(\",d\")\n\nfunction axis(svg) {\n  const g = svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${margin.top})`);\n\n  const axis = d3.axisTop(x)\n      .ticks(width / 160)\n      .tickSizeOuter(0)\n      .tickSizeInner(-barSize * (n + y.padding()));\n\n  return (_, transition) => {\n    g.transition(transition).call(axis);\n    g.select(\".tick:first-of-type text\").remove();\n    g.selectAll(\".tick:not(:first-of-type) line\").attr(\"stroke\", \"white\");\n    g.select(\".domain\").remove();\n  };\n}\n\nfunction ticker(svg) {\n  const now = svg.append(\"text\")\n      .style(\"font\", `bold ${barSize}px var(--sans-serif)`)\n      .style(\"font-variant-numeric\", \"tabular-nums\")\n      .attr(\"text-anchor\", \"end\")\n      .attr(\"x\", width - 6)\n      .attr(\"y\", margin.top + barSize * (n - 0.45))\n      .attr(\"dy\", \"0.32em\")\n      .text(formatDate(keyframes[0][0]));\n\n  return ([date], transition) => {\n    transition.end().then(() => now.text(formatDate(date)));\n  };\n}\n\nformatDate = d3.utcFormat(\"%Y\")\n\ncolor = {\n  const scale = d3.scaleSequential(d3.interpolate(\"red\", \"blue\")).domain([1, 48]);\n  if (data.some(d => d.category !== undefined)) {\n    const categoryByName = new Map(data.map(d => [d.name, d.category]))\n    scale.domain(Array.from(categoryByName.values()));\n    return d => scale(categoryByName.get(d.name));\n  }\n  return d => scale(d.name);\n}\n\n\n<!-- color = { -->\n<!--   const scale = d3.scaleSequential(d3.interpolate(\"red\", \"blue\")).domain([1, 48]); -->\n<!--   if (data.some(d => d.category !== undefined)) { -->\n<!--     const categoryByName = new Map(data.map(d => [d.name, d.category])); -->\n<!--     const categories = Array.from(categoryByName.values()).filter((d, i, arr) => arr.indexOf(d) === i); -->\n<!--     const scaleByCategory = typeof categories[0] === \"number\" ?  -->\n<!--       d3.scaleSequential(d3.interpolateSpectral).domain(d3.extent(categories)) : -->\n<!--       d3.scaleOrdinal().domain(categories).range(d3.quantize(d3.interpolateSpectral, categories.length)); -->\n<!--     return d => scale(scaleByCategory(categoryByName.get(d.name))); -->\n<!--   } -->\n<!--   return (d, i) => scale(i); -->\n<!-- } -->\n\nx = d3.scaleLinear([0, 1], [margin.left, width - margin.right])\n\ny = d3.scaleBand()\n    .domain(d3.range(n + 1))\n    .rangeRound([margin.top, margin.top + barSize * (n + 1 + 0.1)])\n    .padding(0.1)\n    \nheight = margin.top + barSize * n + margin.bottom\n\nbarSize = 48\n\nmargin = ({top: 16, right: 6, bottom: 6, left: 0})\n\nd3 = require(\"d3@6\")\n\n```\n\n\n\n\n### Conclusions or Summary\n\nAnswer your research question. Draw a conclusion or inference related to your topic. Summarize your results. What new questions have emerged as a result of your visualizations? What interesting next steps have emerged?\n\n## RUBRIC\n\nI will evaluate the following for your portfolio post:\n\n**1. Clarity of writing (15%):** Complete, clear sentences. Good Grammar. Understandable to target audience. Logical flow of ideas.\n\n**2. Adherence to format (10%):** Did you follow directions?\n\n**3. Topic suitability (15%):** Is the topic interesting? Are the visualizations challenging and interesting enough to showcase your skills?\n\n**4. Viz Execution (40%):** Are the visualizations effective? Do they adhere to the principles of effectiveness? Are choices for idiom, marks, channels, etc made deliberately and well justified?\n\n**5. Creativity (20%):** Did you push your boundaries and learn new techniques? Is the overall post compelling and interesting? Are the visualizations inspiring, creative, unique, and generally impressive? If I were recruiting a new data scientist (and I often am), would this portfolio post impress me, or would it damage your candidacy during review?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}