---
title: "BCB 520 - Midterm Portfolio Post"
subtitle: "State Level Infection Dynamics of the Zombie Apocalypse"
format:
  html:
    toc: false
    echo: false
author: "Barrie Robison"
date: "2023-04-04"
categories: [Portfolio, DataViz, Infectious Disease, Observable, Animation]
image: "Zomsimmesh.png"
description: "Animating the dynamics of zombie spatial disease ecology."
code-fold: true
code-tools: true
---

## OVERVIEW

This assignment provides you the opportunity to synthesize all of the concepts we've covered in the course to date. The basic framework is that you will create a COMPLETE data visualization BLOG post that is suitable as a showcase component of your Data Science Portfolio. The point is to [SHOW]{.red} people your skills.

## STRUCTURE

The basic formatting guidelines for this assignment are:

1.  Include `code fold` or `code tools` options (or both) that allow users to view and copy your code while maintaining overall readability of your post.
2.  Suppress all output and warnings that might distract from your visualizations and writing.
3.  Properly title your assignment. The main title should be **"BCB 520 - Midterm Portfolio Post"**, and the subtitle should be a descriptive title related to your question or topic.
4.  Include author, date, categories, and a description in your YAML header.
5.  Write clear, complete sentences for a target audience with some scientific background but little training in your specific discipline.
6.  Include references if appropriate and use hyperlinks to external sources of data, inspiration, or examples.
7.  Use the header hierarchy and create a sensible document outline with white space. Format for readability! Use **bold** and *italic* fonts to emphasize things! Use [color]{.red} by customizing your `.css` file!

**In addition to the above formatting guidelines, your portfolio post must contain the following sections:**

## PREAMBLE
```{r}
library(tidyverse)
library(lubridate)
library(readxl)
```
ZOMBIES.

Zombies have undergone a significant evolution as a horror trope in fiction. The concept of zombies dates back to Haitian folklore and Voodoo, where they were depicted as reanimated corpses that were controlled by a sorcerer or bokor. However, in modern fiction, zombies are typically portrayed as mindless, flesh-eating creatures that are reanimated by a virus or some other mysterious force.

The evolution of zombies as a horror trope can be divided into several distinct eras:

1. Classic Zombies: The classic zombie was the original Haitian zombie, which was introduced to Western audiences in the early 20th century through literature and film. These zombies were depicted as slow-moving, mind-controlled creatures that were raised from the dead by Voodoo magic.

2. Romero Zombies: George A. Romero's 1968 film "Night of the Living Dead" redefined the zombie genre by introducing the idea that zombies were reanimated by a mysterious virus that spread through bites and scratches. Romero's zombies were slow-moving, flesh-eating creatures that could only be killed by destroying the brain.

3. Fast Zombies: In the early 2000s, a new type of zombie emerged in fiction that could run and move at incredible speeds. These fast zombies were popularized by films like "28 Days Later" and "World War Z." Fast zombies are often depicted as being more aggressive and intelligent than their slow-moving counterparts.

4. Post-Apocalyptic Zombies: In recent years, zombies have been featured in a number of post-apocalyptic settings, where they are often portrayed as the cause of a global pandemic that has devastated humanity. These stories often focus on the struggle of survivors to rebuild civilization in a world overrun by the undead.

Overall, the evolution of zombies as a horror trope has been marked by a shift from mind-controlled creatures to virus-infected monsters. 

But would an outbreak of a "zombie virus" actually consume the world and bring forth an apocalyptic new age of shambling horror?

Let's use disease modeling to find out!

## Data

I'm going to use our new interactive simulation, [OUTBREAK SIMULATOR](https://professorpolymorphic.github.io/PolymorphicWeb/Games/OutbreakSimulator/), to understand the dynamics of a zombie virus outbreak.

### Parameters

In order to model this outbreak, we'll need to set some of the classic parameters of an SIR compartment model. Outbreak Simulator uses a compartment model of disease (Weissman et al., 2020) in which the population is divided into categories (Figure 1): Susceptible (S), Exposed (E), Infected (I), Vaccinated (V), Recovered (R), or Deceased (D). The model estimates the rates of exchange between categories over a given time interval (t) using differential equations. When the model parameters are known and key assumptions are met, the differential equations can estimate the epidemic curve of an outbreak. The two most critical assumptions are that the population is homogeneous and well mixed and is fixed in size. 

![](OSFig1.jpg)

I've provided my own estimates of these parameters for various infectious zombie franchises in the table below.

```{r}
params<-read_xlsx("params.xlsx")

knitr::kable(params)

```

### Data Dictionary

Outbreak Simulator runs the compartment model on a spatially explicit grid of the continental US.  It writes the number of individuals in each compartment (SIERD) at each time step (an hour) for each of the 48 states and the total population. 

This is a video of the simulation:

![](zombievid.3gp)

```{r}
df<-read.csv("ZombieData.csv")
glimpse(df)

```

I'll manipulate the raw data a bit to get to the visualizations I need.  First, I want a tidy data set with only the total US population.

```{r}

df<-df%>%
  mutate_at(c(1:295), as.numeric)

dftotal <- df%>%
  select(Time, starts_with("Totals_"))%>%
  rename(Time=Time,
          S=Totals_S,
         E=Totals_E,
         V=Totals_V,
         I=Totals_I,
         R=Totals_R,
         D=Totals_D)

for (i in 1:length(dftotal$Time)){
  
  dftotal$dS[i] <- dftotal$S[i]-dftotal$S[i+1]
  dftotal$dR[i] <- dftotal$R[i+1]-dftotal$R[i]
  dftotal$dI[i] <- dftotal$I[i+1]-dftotal$I[i]
  dftotal$dD[i] <- dftotal$D[i+1]-dftotal$D[i]

}

dftotal<- dftotal%>%
  mutate(N= S+E+I+V+R+D)%>%
  mutate(Beta = dS*N/(S*I+1))%>%
  mutate(Gamma = dD/(I+1))%>%
  mutate(R0 = Beta/Gamma)%>%
  filter(Beta<10)%>%
  filter(R0<10^3)

dflong<-dftotal%>%
  pivot_longer(cols = c("S", "E", "I",
                        "V", "R", "D"),names_to = "Compartment", values_to = "Count")

dflong <- dflong%>%
  mutate(Compartment = recode(Compartment, 
         S = "Susceptible",
         E = "Exposed",
         I = "Infected",
         V = "Vaccinated",
         R = "Recovered",
         D = "Deceased"))%>%
  filter(Compartment != "Vaccinated")

```
This allows me to produce the classic Epidemilogical Curve:

```{r}

ggplot(dflong, aes(x=Time, y = Count/10^6, color = Compartment))+
  geom_line()+
   labs(
    title = "Epidemiological Curve",
    subtitle = "Resident Evil - T Virus",
    caption = "Data from a single run of Outbreak Simulator.",
    tag = "Figure 1",
    x = "Time (h)",
    y = "Number of Individuals (millions)",
    colour = "Compartment"
  )+
   scale_colour_brewer(type = "seq", palette = "Spectral")


```


## STATE LEVEL DYNAMICS

```{r}



stateslong <- df %>%
  pivot_longer(cols = 2:295,
               names_to = c("State", "Compartment"),
  names_pattern = "(.+?)_(.)",
  values_to = "Count")

fewerstates<-stateslong%>%
  filter(State == "New.Mexico" | State == "Idaho"
         | State =="Nevada" | State == "New.Hampshire"
         )%>%
    mutate(Compartment = recode(Compartment, 
         S = "Susceptible",
         E = "Exposed",
         I = "Infected",
         V = "Vaccinated",
         R = "Recovered",
         D = "Deceased"))%>%
  filter(Compartment != "Vaccinated")


ggplot(fewerstates, aes(x=Time, y = Count/10^6, color = Compartment))+
  geom_line()+
  facet_wrap(~State)+
   labs(
    title = "Epidemiological Curve",
    subtitle = "H1N1 Influenza",
    caption = "Data from a single run of Outbreak Simulator.",
    tag = "Figure 2",
    x = "Time (h)",
    y = "Number of Individuals (millions)",
    colour = "Compartment"
  )+
   scale_colour_brewer(type = "seq", palette = "Spectral")

Zomstates <- stateslong %>%
  filter(Compartment == "S" & State != "Totals")%>%
  mutate(date = as_date(Time),
         name = State,
         category = Compartment,
         value = Count)%>%
  select(c(5:8))

write.csv(Zomstates, "Zomstates.csv")

```
### Visualizations

Create your visualizations and include text that explains any steps or design choices. Be sure to include clearly labeled axes and a concise but complete figure caption for each visualization. Make deliberate choices for color palettes, point marks, line types, etc. Demonstrate that you understand the concepts we have covered!


https://observablehq.com/d/c28318bc4edfb4c1

```{ojs}

data = d3.csvParse(await FileAttachment("Zomstates.csv").text(), d3.autoType)

viewof replay = html`<button>Replay`

```

```{ojs}



chart = {
  
  replay;

  const svg = d3.create("svg")
      .attr("viewBox", [0, 0, width, height]);

  const updateBars = bars(svg);
  const updateAxis = axis(svg);
  const updateLabels = labels(svg);
  const updateTicker = ticker(svg);

  yield svg.node();

  for (const keyframe of keyframes) {
    const transition = svg.transition()
        .duration(duration)
        .ease(d3.easeLinear);

    // Extract the top barâ€™s value.
    x.domain([0, keyframe[1][0].value]);

    updateAxis(keyframe, transition);
    updateBars(keyframe, transition);
    updateLabels(keyframe, transition);
    updateTicker(keyframe, transition);

    invalidation.then(() => svg.interrupt());
    await transition.end();
  }
}


duration = 25
n = 50
k = 10
names = new Set(data.map(d => d.name))


datevalues = Array.from(d3.rollup(data, ([d]) => d.value, d => +d.date, d => d.name))
  .map(([date, data]) => [new Date(date), data])
  .sort(([a], [b]) => d3.ascending(a, b))
  
  
function rank(value) {
  const data = Array.from(names, name => ({name, value: value(name)}));
  data.sort((a, b) => d3.descending(a.value, b.value));
  for (let i = 0; i < data.length; ++i) data[i].rank = Math.min(n, i);
  return data;
}

keyframes = {
  const keyframes = [];
  let ka, a, kb, b;
  for ([[ka, a], [kb, b]] of d3.pairs(datevalues)) {
    for (let i = 0; i < k; ++i) {
      const t = i / k;
      keyframes.push([
        new Date(ka * (1 - t) + kb * t),
        rank(name => (a.get(name) || 0) * (1 - t) + (b.get(name) || 0) * t)
      ]);
    }
  }
  keyframes.push([new Date(kb), rank(name => b.get(name) || 0)]);
  return keyframes;
}

nameframes = d3.groups(keyframes.flatMap(([, data]) => data), d => d.name)

prev = new Map(nameframes.flatMap(([, data]) => d3.pairs(data, (a, b) => [b, a])))

next = new Map(nameframes.flatMap(([, data]) => d3.pairs(data)))

function bars(svg) {
  let bar = svg.append("g")
      .attr("fill-opacity", 0.6)
    .selectAll("rect");

  return ([date, data], transition) => bar = bar
    .data(data.slice(0, n), d => d.name)
    .join(
      enter => enter.append("rect")
        .attr("fill", color)
        .attr("height", y.bandwidth())
        .attr("x", x(0))
        .attr("y", d => y((prev.get(d) || d).rank))
        .attr("width", d => x((prev.get(d) || d).value) - x(0)),
      update => update,
      exit => exit.transition(transition).remove()
        .attr("y", d => y((next.get(d) || d).rank))
        .attr("width", d => x((next.get(d) || d).value) - x(0))
    )
    .call(bar => bar.transition(transition)
      .attr("y", d => y(d.rank))
      .attr("width", d => x(d.value) - x(0)));
}


function labels(svg) {
  let label = svg.append("g")
      .style("font", "bold 12px var(--sans-serif)")
      .style("font-variant-numeric", "tabular-nums")
      .attr("text-anchor", "end")
    .selectAll("text");

  return ([date, data], transition) => label = label
    .data(data.slice(0, n), d => d.name)
    .join(
      enter => enter.append("text")
        .attr("transform", d => `translate(${x((prev.get(d) || d).value)},${y((prev.get(d) || d).rank)})`)
        .attr("y", y.bandwidth() / 2)
        .attr("x", -6)
        .attr("dy", "-0.25em")
        .text(d => d.name)
        .call(text => text.append("tspan")
          .attr("fill-opacity", 0.7)
          .attr("font-weight", "normal")
          .attr("x", -6)
          .attr("dy", "1.15em")),
      update => update,
      exit => exit.transition(transition).remove()
        .attr("transform", d => `translate(${x((next.get(d) || d).value)},${y((next.get(d) || d).rank)})`)
        .call(g => g.select("tspan").tween("text", d => textTween(d.value, (next.get(d) || d).value)))
    )
    .call(bar => bar.transition(transition)
      .attr("transform", d => `translate(${x(d.value)},${y(d.rank)})`)
      .call(g => g.select("tspan").tween("text", d => textTween((prev.get(d) || d).value, d.value))))
}

function textTween(a, b) {
  const i = d3.interpolateNumber(a, b);
  return function(t) {
    this.textContent = formatNumber(i(t));
  };
}

formatNumber = d3.format(",d")

function axis(svg) {
  const g = svg.append("g")
      .attr("transform", `translate(0,${margin.top})`);

  const axis = d3.axisTop(x)
      .ticks(width / 160)
      .tickSizeOuter(0)
      .tickSizeInner(-barSize * (n + y.padding()));

  return (_, transition) => {
    g.transition(transition).call(axis);
    g.select(".tick:first-of-type text").remove();
    g.selectAll(".tick:not(:first-of-type) line").attr("stroke", "white");
    g.select(".domain").remove();
  };
}

function ticker(svg) {
  const now = svg.append("text")
      .style("font", `bold ${barSize}px var(--sans-serif)`)
      .style("font-variant-numeric", "tabular-nums")
      .attr("text-anchor", "end")
      .attr("x", width - 6)
      .attr("y", margin.top + barSize * (n - 0.45))
      .attr("dy", "0.32em")
      .text(formatDate(keyframes[0][0]));

  return ([date], transition) => {
    transition.end().then(() => now.text(formatDate(date)));
  };
}

formatDate = d3.utcFormat("%Y")

color = {
  const scale = d3.scaleOrdinal(d3.schemeTableau10);
  if (data.some(d => d.category !== undefined)) {
    const categoryByName = new Map(data.map(d => [d.name, d.category]))
    scale.domain(Array.from(categoryByName.values()));
    return d => scale(categoryByName.get(d.name));
  }
  return d => scale(d.name);
}

x = d3.scaleLinear([0, 1], [margin.left, width - margin.right])

y = d3.scaleBand()
    .domain(d3.range(n + 1))
    .rangeRound([margin.top, margin.top + barSize * (n + 1 + 0.1)])
    .padding(0.1)
    
height = margin.top + barSize * n + margin.bottom

barSize = 48

margin = ({top: 16, right: 6, bottom: 6, left: 0})

d3 = require("d3@6")



```



### Conclusions or Summary

Answer your research question. Draw a conclusion or inference related to your topic. Summarize your results. What new questions have emerged as a result of your visualizations? What interesting next steps have emerged?

## RUBRIC

I will evaluate the following for your portfolio post:

**1. Clarity of writing (15%):** Complete, clear sentences. Good Grammar. Understandable to target audience. Logical flow of ideas.

**2. Adherence to format (10%):** Did you follow directions?

**3. Topic suitability (15%):** Is the topic interesting? Are the visualizations challenging and interesting enough to showcase your skills?

**4. Viz Execution (40%):** Are the visualizations effective? Do they adhere to the principles of effectiveness? Are choices for idiom, marks, channels, etc made deliberately and well justified?

**5. Creativity (20%):** Did you push your boundaries and learn new techniques? Is the overall post compelling and interesting? Are the visualizations inspiring, creative, unique, and generally impressive? If I were recruiting a new data scientist (and I often am), would this portfolio post impress me, or would it damage your candidacy during review?
